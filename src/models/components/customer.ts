/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type Name = {
  /**
   * The first name of the customer
   */
  first: string;
  /**
   * The last name of the customer
   */
  last: string;
  /**
   * What the customer prefers to be called
   */
  nickname: string | null;
};

/**
 * The customer's gender, null if unknown or other
 */
export const Gender = {
  Male: "male",
  Female: "female",
} as const;
/**
 * The customer's gender, null if unknown or other
 */
export type Gender = ClosedEnum<typeof Gender>;

/**
 * Customer address. Defaults to an empty string if no value is set.
 */
export type CustomerAddress = {
  /**
   * The primary street address of the customer
   */
  line1: string;
  /**
   * An additional street address line for the customer
   */
  line2: string;
  /**
   * The city where the customer resides
   */
  city: string;
  /**
   * The country where the customer resides
   */
  country: string;
  /**
   * The state or province where the customer resides
   */
  state: string;
  /**
   * The postal code of the customer's address
   */
  zip: string;
};

/**
 * A default full account is a primary account. It may have one or more linked accounts associated with it.
 */
export type Two = {
  type?: "primary" | undefined;
};

/**
 * A linked account may be linked to exactly one primary account. Linked accounts may have limited permissions and depend on the primary account for billing and other functionality.
 */
export type One = {
  type?: "linked" | undefined;
  /**
   * The UUID of the primary account
   */
  primaryCustomerId: string;
};

export type Account = (One & { type: "linked" }) | (Two & { type: "primary" });

export type EmergencyContact = {
  /**
   * The name of the emergency contact
   */
  name: string;
  /**
   * The phone number of the emergency contact
   */
  phone: string;
  /**
   * The relationship of the emergency contact to the customer
   */
  relationship: string;
};

export type MembershipDetails = {
  /**
   * The date the customer first became a member
   */
  initialMembershipStartDate: string | null;
};

/**
 * The role of the customer within the company (e.g., admin, coach, member)
 */
export const CustomerRole = {
  Superuser: "superuser",
  Admin: "admin",
  Coach: "coach",
  Frontdesk: "frontdesk",
  Member: "member",
  NonMember: "non-member",
  ExMember: "ex-member",
  Lead: "lead",
} as const;
/**
 * The role of the customer within the company (e.g., admin, coach, member)
 */
export type CustomerRole = ClosedEnum<typeof CustomerRole>;

/**
 * Schema representing a customer, former customer, or lead served by the company
 */
export type Customer = {
  /**
   * A unique identifier assigned to each customer
   */
  id: string;
  /**
   * The unique identifier of the company the customer belongs to
   */
  companyId: string;
  name: Name;
  /**
   * The customer's gender, null if unknown or other
   */
  gender: Gender | null;
  /**
   * The customer's date of birth, null if not provided, formatted YYYY-MM-DD
   */
  dob: string | null;
  /**
   * Customer address. Defaults to an empty string if no value is set.
   */
  address: CustomerAddress;
  /**
   * The UUID of the assigned staff member
   */
  assignedToStaffId?: string | null | undefined;
  account: (One & { type: "linked" }) | (Two & { type: "primary" });
  /**
   * A URL pointing to the customer's profile image
   */
  profileImage?: string | null | undefined;
  emergencyContact?: EmergencyContact | undefined;
  membershipDetails: MembershipDetails | null;
  /**
   * The email address of the customer
   */
  email: string;
  /**
   * The phone number of the customer
   */
  phone?: string | null | undefined;
  /**
   * The role of the customer within the company (e.g., admin, coach, member)
   */
  role?: CustomerRole | null | undefined;
};

/** @internal */
export const Name$inboundSchema: z.ZodType<Name, z.ZodTypeDef, unknown> = z
  .object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });
/** @internal */
export type Name$Outbound = {
  first: string;
  last: string;
  nickname: string | null;
};

/** @internal */
export const Name$outboundSchema: z.ZodType<Name$Outbound, z.ZodTypeDef, Name> =
  z.object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });

export function nameToJSON(name: Name): string {
  return JSON.stringify(Name$outboundSchema.parse(name));
}
export function nameFromJSON(
  jsonString: string,
): SafeParseResult<Name, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Name$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Name' from JSON`,
  );
}

/** @internal */
export const Gender$inboundSchema: z.ZodNativeEnum<typeof Gender> = z
  .nativeEnum(Gender);
/** @internal */
export const Gender$outboundSchema: z.ZodNativeEnum<typeof Gender> =
  Gender$inboundSchema;

/** @internal */
export const CustomerAddress$inboundSchema: z.ZodType<
  CustomerAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  line1: z.string(),
  line2: z.string(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  zip: z.string(),
});
/** @internal */
export type CustomerAddress$Outbound = {
  line1: string;
  line2: string;
  city: string;
  country: string;
  state: string;
  zip: string;
};

/** @internal */
export const CustomerAddress$outboundSchema: z.ZodType<
  CustomerAddress$Outbound,
  z.ZodTypeDef,
  CustomerAddress
> = z.object({
  line1: z.string(),
  line2: z.string(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  zip: z.string(),
});

export function customerAddressToJSON(
  customerAddress: CustomerAddress,
): string {
  return JSON.stringify(CustomerAddress$outboundSchema.parse(customerAddress));
}
export function customerAddressFromJSON(
  jsonString: string,
): SafeParseResult<CustomerAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomerAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomerAddress' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("primary").default("primary").optional(),
  });
/** @internal */
export type Two$Outbound = {
  type: "primary";
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: z.literal("primary"),
  });

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}
export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("linked").default("linked").optional(),
    primaryCustomerId: z.string(),
  });
/** @internal */
export type One$Outbound = {
  type: "linked";
  primaryCustomerId: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: z.literal("linked"),
    primaryCustomerId: z.string(),
  });

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}
export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const Account$inboundSchema: z.ZodType<Account, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => One$inboundSchema).and(
      z.object({ type: z.literal("linked") }),
    ),
    z.lazy(() => Two$inboundSchema).and(
      z.object({ type: z.literal("primary") }),
    ),
  ]);
/** @internal */
export type Account$Outbound =
  | (One$Outbound & { type: "linked" })
  | (Two$Outbound & { type: "primary" });

/** @internal */
export const Account$outboundSchema: z.ZodType<
  Account$Outbound,
  z.ZodTypeDef,
  Account
> = z.union([
  z.lazy(() => One$outboundSchema).and(z.object({ type: z.literal("linked") })),
  z.lazy(() => Two$outboundSchema).and(
    z.object({ type: z.literal("primary") }),
  ),
]);

export function accountToJSON(account: Account): string {
  return JSON.stringify(Account$outboundSchema.parse(account));
}
export function accountFromJSON(
  jsonString: string,
): SafeParseResult<Account, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Account$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Account' from JSON`,
  );
}

/** @internal */
export const EmergencyContact$inboundSchema: z.ZodType<
  EmergencyContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});
/** @internal */
export type EmergencyContact$Outbound = {
  name: string;
  phone: string;
  relationship: string;
};

/** @internal */
export const EmergencyContact$outboundSchema: z.ZodType<
  EmergencyContact$Outbound,
  z.ZodTypeDef,
  EmergencyContact
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});

export function emergencyContactToJSON(
  emergencyContact: EmergencyContact,
): string {
  return JSON.stringify(
    EmergencyContact$outboundSchema.parse(emergencyContact),
  );
}
export function emergencyContactFromJSON(
  jsonString: string,
): SafeParseResult<EmergencyContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmergencyContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmergencyContact' from JSON`,
  );
}

/** @internal */
export const MembershipDetails$inboundSchema: z.ZodType<
  MembershipDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  initialMembershipStartDate: z.nullable(z.string()),
});
/** @internal */
export type MembershipDetails$Outbound = {
  initialMembershipStartDate: string | null;
};

/** @internal */
export const MembershipDetails$outboundSchema: z.ZodType<
  MembershipDetails$Outbound,
  z.ZodTypeDef,
  MembershipDetails
> = z.object({
  initialMembershipStartDate: z.nullable(z.string()),
});

export function membershipDetailsToJSON(
  membershipDetails: MembershipDetails,
): string {
  return JSON.stringify(
    MembershipDetails$outboundSchema.parse(membershipDetails),
  );
}
export function membershipDetailsFromJSON(
  jsonString: string,
): SafeParseResult<MembershipDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MembershipDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MembershipDetails' from JSON`,
  );
}

/** @internal */
export const CustomerRole$inboundSchema: z.ZodNativeEnum<typeof CustomerRole> =
  z.nativeEnum(CustomerRole);
/** @internal */
export const CustomerRole$outboundSchema: z.ZodNativeEnum<typeof CustomerRole> =
  CustomerRole$inboundSchema;

/** @internal */
export const Customer$inboundSchema: z.ZodType<
  Customer,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  companyId: z.string(),
  name: z.lazy(() => Name$inboundSchema),
  gender: z.nullable(Gender$inboundSchema),
  dob: z.nullable(z.string()),
  address: z.lazy(() => CustomerAddress$inboundSchema),
  assignedToStaffId: z.nullable(z.string()).optional(),
  account: z.union([
    z.lazy(() => One$inboundSchema).and(
      z.object({ type: z.literal("linked") }),
    ),
    z.lazy(() => Two$inboundSchema).and(
      z.object({ type: z.literal("primary") }),
    ),
  ]),
  profileImage: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$inboundSchema).optional(),
  membershipDetails: z.nullable(z.lazy(() => MembershipDetails$inboundSchema)),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  role: z.nullable(CustomerRole$inboundSchema).optional(),
});
/** @internal */
export type Customer$Outbound = {
  id: string;
  companyId: string;
  name: Name$Outbound;
  gender: string | null;
  dob: string | null;
  address: CustomerAddress$Outbound;
  assignedToStaffId?: string | null | undefined;
  account:
    | (One$Outbound & { type: "linked" })
    | (Two$Outbound & { type: "primary" });
  profileImage?: string | null | undefined;
  emergencyContact?: EmergencyContact$Outbound | undefined;
  membershipDetails: MembershipDetails$Outbound | null;
  email: string;
  phone?: string | null | undefined;
  role?: string | null | undefined;
};

/** @internal */
export const Customer$outboundSchema: z.ZodType<
  Customer$Outbound,
  z.ZodTypeDef,
  Customer
> = z.object({
  id: z.string(),
  companyId: z.string(),
  name: z.lazy(() => Name$outboundSchema),
  gender: z.nullable(Gender$outboundSchema),
  dob: z.nullable(z.string()),
  address: z.lazy(() => CustomerAddress$outboundSchema),
  assignedToStaffId: z.nullable(z.string()).optional(),
  account: z.union([
    z.lazy(() => One$outboundSchema).and(
      z.object({ type: z.literal("linked") }),
    ),
    z.lazy(() => Two$outboundSchema).and(
      z.object({ type: z.literal("primary") }),
    ),
  ]),
  profileImage: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$outboundSchema).optional(),
  membershipDetails: z.nullable(z.lazy(() => MembershipDetails$outboundSchema)),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  role: z.nullable(CustomerRole$outboundSchema).optional(),
});

export function customerToJSON(customer: Customer): string {
  return JSON.stringify(Customer$outboundSchema.parse(customer));
}
export function customerFromJSON(
  jsonString: string,
): SafeParseResult<Customer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Customer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Customer' from JSON`,
  );
}
