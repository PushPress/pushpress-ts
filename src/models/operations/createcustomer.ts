/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateCustomerGlobals = {
  companyId?: string | undefined;
};

/**
 * Customer address. Defaults to an empty string if no value is set.
 */
export type Address = {
  /**
   * The primary street address of the customer
   */
  line1: string;
  /**
   * An additional street address line for the customer
   */
  line2: string;
  /**
   * The city where the customer resides
   */
  city: string;
  /**
   * The country where the customer resides
   */
  country: string;
  /**
   * The state or province where the customer resides
   */
  state: string;
  /**
   * The postal code of the customer's address
   */
  zip: string;
};

export type Name = {
  /**
   * The first name of the customer
   */
  first: string;
  /**
   * The last name of the customer
   */
  last: string;
  /**
   * What the customer prefers to be called
   */
  nickname: string | null;
};

export type EmergencyContact = {
  /**
   * The name of the emergency contact
   */
  name: string;
  /**
   * The phone number of the emergency contact
   */
  phone: string;
  /**
   * The relationship of the emergency contact to the customer
   */
  relationship: string;
};

/**
 * The customer's gender, null if unknown or other
 */
export const Gender = {
  Male: "male",
  Female: "female",
} as const;
/**
 * The customer's gender, null if unknown or other
 */
export type Gender = ClosedEnum<typeof Gender>;

export const AccountType = {
  Primary: "primary",
} as const;
export type AccountType = ClosedEnum<typeof AccountType>;

/**
 * A default full account is a primary account. It may have one or more linked accounts associated with it.
 */
export type Two = {
  type: AccountType;
};

export const Type = {
  Linked: "linked",
} as const;
export type Type = ClosedEnum<typeof Type>;

/**
 * A linked account may be linked to exactly one primary account. Linked accounts may have limited permissions and depend on the primary account for billing and other functionality.
 */
export type One = {
  type: Type;
  /**
   * The UUID of the primary account
   */
  primaryCustomerId: string;
};

export type Account = Two | One;

export type CreateCustomerRequestBody = {
  /**
   * A unique identifier assigned to each customer
   */
  id?: string | undefined;
  /**
   * The UUID of the assigned staff member
   */
  assignedToStaffId?: string | null | undefined;
  /**
   * Customer address. Defaults to an empty string if no value is set.
   */
  address?: Address | undefined;
  name?: Name | undefined;
  /**
   * The email address of the customer
   */
  email: string;
  /**
   * The phone number of the customer
   */
  phone?: string | null | undefined;
  emergencyContact?: EmergencyContact | undefined;
  /**
   * The customer's date of birth, null if not provided, formatted YYYY-MM-DD
   */
  dob?: string | null | undefined;
  /**
   * The customer's gender, null if unknown or other
   */
  gender?: Gender | null | undefined;
  account?: Two | One | undefined;
};

export type CreateCustomerRequest = {
  /**
   * When using multitenant API keys, specify the company
   */
  companyId?: string | undefined;
  requestBody: CreateCustomerRequestBody;
};

/**
 * Default Response
 */
export type CreateCustomerResponseBody = {
  /**
   * A unique identifier assigned to each customer
   */
  id: string;
};

/** @internal */
export const CreateCustomerGlobals$inboundSchema: z.ZodType<
  CreateCustomerGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  "company-id": z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "company-id": "companyId",
  });
});

/** @internal */
export type CreateCustomerGlobals$Outbound = {
  "company-id"?: string | undefined;
};

/** @internal */
export const CreateCustomerGlobals$outboundSchema: z.ZodType<
  CreateCustomerGlobals$Outbound,
  z.ZodTypeDef,
  CreateCustomerGlobals
> = z.object({
  companyId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    companyId: "company-id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerGlobals$ {
  /** @deprecated use `CreateCustomerGlobals$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerGlobals$inboundSchema;
  /** @deprecated use `CreateCustomerGlobals$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerGlobals$outboundSchema;
  /** @deprecated use `CreateCustomerGlobals$Outbound` instead. */
  export type Outbound = CreateCustomerGlobals$Outbound;
}

export function createCustomerGlobalsToJSON(
  createCustomerGlobals: CreateCustomerGlobals,
): string {
  return JSON.stringify(
    CreateCustomerGlobals$outboundSchema.parse(createCustomerGlobals),
  );
}

export function createCustomerGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerGlobals' from JSON`,
  );
}

/** @internal */
export const Address$inboundSchema: z.ZodType<Address, z.ZodTypeDef, unknown> =
  z.object({
    line1: z.string(),
    line2: z.string(),
    city: z.string(),
    country: z.string(),
    state: z.string(),
    zip: z.string(),
  });

/** @internal */
export type Address$Outbound = {
  line1: string;
  line2: string;
  city: string;
  country: string;
  state: string;
  zip: string;
};

/** @internal */
export const Address$outboundSchema: z.ZodType<
  Address$Outbound,
  z.ZodTypeDef,
  Address
> = z.object({
  line1: z.string(),
  line2: z.string(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  zip: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Address$ {
  /** @deprecated use `Address$inboundSchema` instead. */
  export const inboundSchema = Address$inboundSchema;
  /** @deprecated use `Address$outboundSchema` instead. */
  export const outboundSchema = Address$outboundSchema;
  /** @deprecated use `Address$Outbound` instead. */
  export type Outbound = Address$Outbound;
}

export function addressToJSON(address: Address): string {
  return JSON.stringify(Address$outboundSchema.parse(address));
}

export function addressFromJSON(
  jsonString: string,
): SafeParseResult<Address, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Address$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Address' from JSON`,
  );
}

/** @internal */
export const Name$inboundSchema: z.ZodType<Name, z.ZodTypeDef, unknown> = z
  .object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });

/** @internal */
export type Name$Outbound = {
  first: string;
  last: string;
  nickname: string | null;
};

/** @internal */
export const Name$outboundSchema: z.ZodType<Name$Outbound, z.ZodTypeDef, Name> =
  z.object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Name$ {
  /** @deprecated use `Name$inboundSchema` instead. */
  export const inboundSchema = Name$inboundSchema;
  /** @deprecated use `Name$outboundSchema` instead. */
  export const outboundSchema = Name$outboundSchema;
  /** @deprecated use `Name$Outbound` instead. */
  export type Outbound = Name$Outbound;
}

export function nameToJSON(name: Name): string {
  return JSON.stringify(Name$outboundSchema.parse(name));
}

export function nameFromJSON(
  jsonString: string,
): SafeParseResult<Name, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Name$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Name' from JSON`,
  );
}

/** @internal */
export const EmergencyContact$inboundSchema: z.ZodType<
  EmergencyContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});

/** @internal */
export type EmergencyContact$Outbound = {
  name: string;
  phone: string;
  relationship: string;
};

/** @internal */
export const EmergencyContact$outboundSchema: z.ZodType<
  EmergencyContact$Outbound,
  z.ZodTypeDef,
  EmergencyContact
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmergencyContact$ {
  /** @deprecated use `EmergencyContact$inboundSchema` instead. */
  export const inboundSchema = EmergencyContact$inboundSchema;
  /** @deprecated use `EmergencyContact$outboundSchema` instead. */
  export const outboundSchema = EmergencyContact$outboundSchema;
  /** @deprecated use `EmergencyContact$Outbound` instead. */
  export type Outbound = EmergencyContact$Outbound;
}

export function emergencyContactToJSON(
  emergencyContact: EmergencyContact,
): string {
  return JSON.stringify(
    EmergencyContact$outboundSchema.parse(emergencyContact),
  );
}

export function emergencyContactFromJSON(
  jsonString: string,
): SafeParseResult<EmergencyContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmergencyContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmergencyContact' from JSON`,
  );
}

/** @internal */
export const Gender$inboundSchema: z.ZodNativeEnum<typeof Gender> = z
  .nativeEnum(Gender);

/** @internal */
export const Gender$outboundSchema: z.ZodNativeEnum<typeof Gender> =
  Gender$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Gender$ {
  /** @deprecated use `Gender$inboundSchema` instead. */
  export const inboundSchema = Gender$inboundSchema;
  /** @deprecated use `Gender$outboundSchema` instead. */
  export const outboundSchema = Gender$outboundSchema;
}

/** @internal */
export const AccountType$inboundSchema: z.ZodNativeEnum<typeof AccountType> = z
  .nativeEnum(AccountType);

/** @internal */
export const AccountType$outboundSchema: z.ZodNativeEnum<typeof AccountType> =
  AccountType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccountType$ {
  /** @deprecated use `AccountType$inboundSchema` instead. */
  export const inboundSchema = AccountType$inboundSchema;
  /** @deprecated use `AccountType$outboundSchema` instead. */
  export const outboundSchema = AccountType$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: AccountType$inboundSchema,
  });

/** @internal */
export type Two$Outbound = {
  type: string;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: AccountType$outboundSchema,
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: Type$inboundSchema,
    primaryCustomerId: z.string(),
  });

/** @internal */
export type One$Outbound = {
  type: string;
  primaryCustomerId: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: Type$outboundSchema,
    primaryCustomerId: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const Account$inboundSchema: z.ZodType<Account, z.ZodTypeDef, unknown> =
  z.union([z.lazy(() => Two$inboundSchema), z.lazy(() => One$inboundSchema)]);

/** @internal */
export type Account$Outbound = Two$Outbound | One$Outbound;

/** @internal */
export const Account$outboundSchema: z.ZodType<
  Account$Outbound,
  z.ZodTypeDef,
  Account
> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.lazy(() => One$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Account$ {
  /** @deprecated use `Account$inboundSchema` instead. */
  export const inboundSchema = Account$inboundSchema;
  /** @deprecated use `Account$outboundSchema` instead. */
  export const outboundSchema = Account$outboundSchema;
  /** @deprecated use `Account$Outbound` instead. */
  export type Outbound = Account$Outbound;
}

export function accountToJSON(account: Account): string {
  return JSON.stringify(Account$outboundSchema.parse(account));
}

export function accountFromJSON(
  jsonString: string,
): SafeParseResult<Account, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Account$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Account' from JSON`,
  );
}

/** @internal */
export const CreateCustomerRequestBody$inboundSchema: z.ZodType<
  CreateCustomerRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  assignedToStaffId: z.nullable(z.string()).optional(),
  address: z.lazy(() => Address$inboundSchema).optional(),
  name: z.lazy(() => Name$inboundSchema).optional(),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$inboundSchema).optional(),
  dob: z.nullable(z.string()).optional(),
  gender: z.nullable(Gender$inboundSchema).optional(),
  account: z.union([
    z.lazy(() => Two$inboundSchema),
    z.lazy(() => One$inboundSchema),
  ]).optional(),
});

/** @internal */
export type CreateCustomerRequestBody$Outbound = {
  id?: string | undefined;
  assignedToStaffId?: string | null | undefined;
  address?: Address$Outbound | undefined;
  name?: Name$Outbound | undefined;
  email: string;
  phone?: string | null | undefined;
  emergencyContact?: EmergencyContact$Outbound | undefined;
  dob?: string | null | undefined;
  gender?: string | null | undefined;
  account?: Two$Outbound | One$Outbound | undefined;
};

/** @internal */
export const CreateCustomerRequestBody$outboundSchema: z.ZodType<
  CreateCustomerRequestBody$Outbound,
  z.ZodTypeDef,
  CreateCustomerRequestBody
> = z.object({
  id: z.string().optional(),
  assignedToStaffId: z.nullable(z.string()).optional(),
  address: z.lazy(() => Address$outboundSchema).optional(),
  name: z.lazy(() => Name$outboundSchema).optional(),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$outboundSchema).optional(),
  dob: z.nullable(z.string()).optional(),
  gender: z.nullable(Gender$outboundSchema).optional(),
  account: z.union([
    z.lazy(() => Two$outboundSchema),
    z.lazy(() => One$outboundSchema),
  ]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerRequestBody$ {
  /** @deprecated use `CreateCustomerRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerRequestBody$inboundSchema;
  /** @deprecated use `CreateCustomerRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerRequestBody$outboundSchema;
  /** @deprecated use `CreateCustomerRequestBody$Outbound` instead. */
  export type Outbound = CreateCustomerRequestBody$Outbound;
}

export function createCustomerRequestBodyToJSON(
  createCustomerRequestBody: CreateCustomerRequestBody,
): string {
  return JSON.stringify(
    CreateCustomerRequestBody$outboundSchema.parse(createCustomerRequestBody),
  );
}

export function createCustomerRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateCustomerRequest$inboundSchema: z.ZodType<
  CreateCustomerRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "company-id": z.string().optional(),
  RequestBody: z.lazy(() => CreateCustomerRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "company-id": "companyId",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateCustomerRequest$Outbound = {
  "company-id"?: string | undefined;
  RequestBody: CreateCustomerRequestBody$Outbound;
};

/** @internal */
export const CreateCustomerRequest$outboundSchema: z.ZodType<
  CreateCustomerRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerRequest
> = z.object({
  companyId: z.string().optional(),
  requestBody: z.lazy(() => CreateCustomerRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    companyId: "company-id",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerRequest$ {
  /** @deprecated use `CreateCustomerRequest$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerRequest$inboundSchema;
  /** @deprecated use `CreateCustomerRequest$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerRequest$outboundSchema;
  /** @deprecated use `CreateCustomerRequest$Outbound` instead. */
  export type Outbound = CreateCustomerRequest$Outbound;
}

export function createCustomerRequestToJSON(
  createCustomerRequest: CreateCustomerRequest,
): string {
  return JSON.stringify(
    CreateCustomerRequest$outboundSchema.parse(createCustomerRequest),
  );
}

export function createCustomerRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerResponseBody$inboundSchema: z.ZodType<
  CreateCustomerResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type CreateCustomerResponseBody$Outbound = {
  id: string;
};

/** @internal */
export const CreateCustomerResponseBody$outboundSchema: z.ZodType<
  CreateCustomerResponseBody$Outbound,
  z.ZodTypeDef,
  CreateCustomerResponseBody
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateCustomerResponseBody$ {
  /** @deprecated use `CreateCustomerResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateCustomerResponseBody$inboundSchema;
  /** @deprecated use `CreateCustomerResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateCustomerResponseBody$outboundSchema;
  /** @deprecated use `CreateCustomerResponseBody$Outbound` instead. */
  export type Outbound = CreateCustomerResponseBody$Outbound;
}

export function createCustomerResponseBodyToJSON(
  createCustomerResponseBody: CreateCustomerResponseBody,
): string {
  return JSON.stringify(
    CreateCustomerResponseBody$outboundSchema.parse(createCustomerResponseBody),
  );
}

export function createCustomerResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerResponseBody' from JSON`,
  );
}
