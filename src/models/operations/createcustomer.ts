/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateCustomerGlobals = {
  companyId?: string | undefined;
};

/**
 * Customer address. Defaults to an empty string if no value is set.
 */
export type Address = {
  /**
   * The primary street address of the customer
   */
  line1: string;
  /**
   * An additional street address line for the customer
   */
  line2: string;
  /**
   * The city where the customer resides
   */
  city: string;
  /**
   * The country where the customer resides
   */
  country: string;
  /**
   * The state or province where the customer resides
   */
  state: string;
  /**
   * The postal code of the customer's address
   */
  zip: string;
};

export type Name = {
  /**
   * The first name of the customer
   */
  first: string;
  /**
   * The last name of the customer
   */
  last: string;
  /**
   * What the customer prefers to be called
   */
  nickname: string | null;
};

export type EmergencyContact = {
  /**
   * The name of the emergency contact
   */
  name: string;
  /**
   * The phone number of the emergency contact
   */
  phone: string;
  /**
   * The relationship of the emergency contact to the customer
   */
  relationship: string;
};

/**
 * The customer's gender, null if unknown or other
 */
export const Gender = {
  Male: "male",
  Female: "female",
} as const;
/**
 * The customer's gender, null if unknown or other
 */
export type Gender = ClosedEnum<typeof Gender>;

/**
 * A default full account is a primary account. It may have one or more linked accounts associated with it.
 */
export type Two = {
  type: "primary";
};

/**
 * A linked account may be linked to exactly one primary account. Linked accounts may have limited permissions and depend on the primary account for billing and other functionality.
 */
export type One = {
  type: "linked";
  /**
   * The UUID of the primary account
   */
  primaryCustomerId: string;
};

export type Account = One | Two;

/**
 * The source of the lead
 */
export const Source = {
  Platform: "PLATFORM",
  GrowSync: "GROW_SYNC",
} as const;
/**
 * The source of the lead
 */
export type Source = ClosedEnum<typeof Source>;

export type CreateCustomerRequestBody = {
  /**
   * A unique identifier assigned to each customer
   */
  id?: string | undefined;
  /**
   * The UUID of the assigned staff member
   */
  assignedToStaffId?: string | null | undefined;
  /**
   * Customer address. Defaults to an empty string if no value is set.
   */
  address?: Address | undefined;
  name?: Name | undefined;
  /**
   * The email address of the customer
   */
  email: string;
  /**
   * The phone number of the customer
   */
  phone?: string | null | undefined;
  emergencyContact?: EmergencyContact | undefined;
  /**
   * The customer's date of birth, null if not provided, formatted YYYY-MM-DD
   */
  dob?: string | null | undefined;
  /**
   * The customer's gender, null if unknown or other
   */
  gender?: Gender | null | undefined;
  account?: One | Two | undefined;
  /**
   * The source of the lead
   */
  source?: Source | undefined;
};

export type CreateCustomerRequest = {
  /**
   * When using multitenant API keys, specify the company
   */
  companyId?: string | undefined;
  requestBody: CreateCustomerRequestBody;
};

/**
 * Default Response
 */
export type CreateCustomerResponseBody = {
  /**
   * A unique identifier assigned to each customer
   */
  id: string;
};

/** @internal */
export const CreateCustomerGlobals$inboundSchema: z.ZodType<
  CreateCustomerGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  "company-id": z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "company-id": "companyId",
  });
});
/** @internal */
export type CreateCustomerGlobals$Outbound = {
  "company-id"?: string | undefined;
};

/** @internal */
export const CreateCustomerGlobals$outboundSchema: z.ZodType<
  CreateCustomerGlobals$Outbound,
  z.ZodTypeDef,
  CreateCustomerGlobals
> = z.object({
  companyId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    companyId: "company-id",
  });
});

export function createCustomerGlobalsToJSON(
  createCustomerGlobals: CreateCustomerGlobals,
): string {
  return JSON.stringify(
    CreateCustomerGlobals$outboundSchema.parse(createCustomerGlobals),
  );
}
export function createCustomerGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerGlobals' from JSON`,
  );
}

/** @internal */
export const Address$inboundSchema: z.ZodType<Address, z.ZodTypeDef, unknown> =
  z.object({
    line1: z.string(),
    line2: z.string(),
    city: z.string(),
    country: z.string(),
    state: z.string(),
    zip: z.string(),
  });
/** @internal */
export type Address$Outbound = {
  line1: string;
  line2: string;
  city: string;
  country: string;
  state: string;
  zip: string;
};

/** @internal */
export const Address$outboundSchema: z.ZodType<
  Address$Outbound,
  z.ZodTypeDef,
  Address
> = z.object({
  line1: z.string(),
  line2: z.string(),
  city: z.string(),
  country: z.string(),
  state: z.string(),
  zip: z.string(),
});

export function addressToJSON(address: Address): string {
  return JSON.stringify(Address$outboundSchema.parse(address));
}
export function addressFromJSON(
  jsonString: string,
): SafeParseResult<Address, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Address$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Address' from JSON`,
  );
}

/** @internal */
export const Name$inboundSchema: z.ZodType<Name, z.ZodTypeDef, unknown> = z
  .object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });
/** @internal */
export type Name$Outbound = {
  first: string;
  last: string;
  nickname: string | null;
};

/** @internal */
export const Name$outboundSchema: z.ZodType<Name$Outbound, z.ZodTypeDef, Name> =
  z.object({
    first: z.string(),
    last: z.string(),
    nickname: z.nullable(z.string()),
  });

export function nameToJSON(name: Name): string {
  return JSON.stringify(Name$outboundSchema.parse(name));
}
export function nameFromJSON(
  jsonString: string,
): SafeParseResult<Name, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Name$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Name' from JSON`,
  );
}

/** @internal */
export const EmergencyContact$inboundSchema: z.ZodType<
  EmergencyContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});
/** @internal */
export type EmergencyContact$Outbound = {
  name: string;
  phone: string;
  relationship: string;
};

/** @internal */
export const EmergencyContact$outboundSchema: z.ZodType<
  EmergencyContact$Outbound,
  z.ZodTypeDef,
  EmergencyContact
> = z.object({
  name: z.string(),
  phone: z.string(),
  relationship: z.string(),
});

export function emergencyContactToJSON(
  emergencyContact: EmergencyContact,
): string {
  return JSON.stringify(
    EmergencyContact$outboundSchema.parse(emergencyContact),
  );
}
export function emergencyContactFromJSON(
  jsonString: string,
): SafeParseResult<EmergencyContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmergencyContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmergencyContact' from JSON`,
  );
}

/** @internal */
export const Gender$inboundSchema: z.ZodNativeEnum<typeof Gender> = z
  .nativeEnum(Gender);
/** @internal */
export const Gender$outboundSchema: z.ZodNativeEnum<typeof Gender> =
  Gender$inboundSchema;

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("primary"),
  });
/** @internal */
export type Two$Outbound = {
  type: "primary";
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: z.literal("primary"),
  });

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}
export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("linked"),
    primaryCustomerId: z.string(),
  });
/** @internal */
export type One$Outbound = {
  type: "linked";
  primaryCustomerId: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: z.literal("linked"),
    primaryCustomerId: z.string(),
  });

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}
export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const Account$inboundSchema: z.ZodType<Account, z.ZodTypeDef, unknown> =
  z.union([z.lazy(() => One$inboundSchema), z.lazy(() => Two$inboundSchema)]);
/** @internal */
export type Account$Outbound = One$Outbound | Two$Outbound;

/** @internal */
export const Account$outboundSchema: z.ZodType<
  Account$Outbound,
  z.ZodTypeDef,
  Account
> = z.union([
  z.lazy(() => One$outboundSchema),
  z.lazy(() => Two$outboundSchema),
]);

export function accountToJSON(account: Account): string {
  return JSON.stringify(Account$outboundSchema.parse(account));
}
export function accountFromJSON(
  jsonString: string,
): SafeParseResult<Account, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Account$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Account' from JSON`,
  );
}

/** @internal */
export const Source$inboundSchema: z.ZodNativeEnum<typeof Source> = z
  .nativeEnum(Source);
/** @internal */
export const Source$outboundSchema: z.ZodNativeEnum<typeof Source> =
  Source$inboundSchema;

/** @internal */
export const CreateCustomerRequestBody$inboundSchema: z.ZodType<
  CreateCustomerRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  assignedToStaffId: z.nullable(z.string()).optional(),
  address: z.lazy(() => Address$inboundSchema).optional(),
  name: z.lazy(() => Name$inboundSchema).optional(),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$inboundSchema).optional(),
  dob: z.nullable(z.string()).optional(),
  gender: z.nullable(Gender$inboundSchema).optional(),
  account: z.union([
    z.lazy(() => One$inboundSchema),
    z.lazy(() => Two$inboundSchema),
  ]).optional(),
  source: Source$inboundSchema.default("PLATFORM"),
});
/** @internal */
export type CreateCustomerRequestBody$Outbound = {
  id?: string | undefined;
  assignedToStaffId?: string | null | undefined;
  address?: Address$Outbound | undefined;
  name?: Name$Outbound | undefined;
  email: string;
  phone?: string | null | undefined;
  emergencyContact?: EmergencyContact$Outbound | undefined;
  dob?: string | null | undefined;
  gender?: string | null | undefined;
  account?: One$Outbound | Two$Outbound | undefined;
  source: string;
};

/** @internal */
export const CreateCustomerRequestBody$outboundSchema: z.ZodType<
  CreateCustomerRequestBody$Outbound,
  z.ZodTypeDef,
  CreateCustomerRequestBody
> = z.object({
  id: z.string().optional(),
  assignedToStaffId: z.nullable(z.string()).optional(),
  address: z.lazy(() => Address$outboundSchema).optional(),
  name: z.lazy(() => Name$outboundSchema).optional(),
  email: z.string(),
  phone: z.nullable(z.string()).optional(),
  emergencyContact: z.lazy(() => EmergencyContact$outboundSchema).optional(),
  dob: z.nullable(z.string()).optional(),
  gender: z.nullable(Gender$outboundSchema).optional(),
  account: z.union([
    z.lazy(() => One$outboundSchema),
    z.lazy(() => Two$outboundSchema),
  ]).optional(),
  source: Source$outboundSchema.default("PLATFORM"),
});

export function createCustomerRequestBodyToJSON(
  createCustomerRequestBody: CreateCustomerRequestBody,
): string {
  return JSON.stringify(
    CreateCustomerRequestBody$outboundSchema.parse(createCustomerRequestBody),
  );
}
export function createCustomerRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateCustomerRequest$inboundSchema: z.ZodType<
  CreateCustomerRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "company-id": z.string().optional(),
  RequestBody: z.lazy(() => CreateCustomerRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "company-id": "companyId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateCustomerRequest$Outbound = {
  "company-id"?: string | undefined;
  RequestBody: CreateCustomerRequestBody$Outbound;
};

/** @internal */
export const CreateCustomerRequest$outboundSchema: z.ZodType<
  CreateCustomerRequest$Outbound,
  z.ZodTypeDef,
  CreateCustomerRequest
> = z.object({
  companyId: z.string().optional(),
  requestBody: z.lazy(() => CreateCustomerRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    companyId: "company-id",
    requestBody: "RequestBody",
  });
});

export function createCustomerRequestToJSON(
  createCustomerRequest: CreateCustomerRequest,
): string {
  return JSON.stringify(
    CreateCustomerRequest$outboundSchema.parse(createCustomerRequest),
  );
}
export function createCustomerRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerRequest' from JSON`,
  );
}

/** @internal */
export const CreateCustomerResponseBody$inboundSchema: z.ZodType<
  CreateCustomerResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});
/** @internal */
export type CreateCustomerResponseBody$Outbound = {
  id: string;
};

/** @internal */
export const CreateCustomerResponseBody$outboundSchema: z.ZodType<
  CreateCustomerResponseBody$Outbound,
  z.ZodTypeDef,
  CreateCustomerResponseBody
> = z.object({
  id: z.string(),
});

export function createCustomerResponseBodyToJSON(
  createCustomerResponseBody: CreateCustomerResponseBody,
): string {
  return JSON.stringify(
    CreateCustomerResponseBody$outboundSchema.parse(createCustomerResponseBody),
  );
}
export function createCustomerResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCustomerResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCustomerResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCustomerResponseBody' from JSON`,
  );
}
